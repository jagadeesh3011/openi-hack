{"ast":null,"code":"import _toConsumableArray from \"C:/Users/320209843/Documents/GitHub/openi-hack/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/320209843/Documents/GitHub/openi-hack/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/320209843/Documents/GitHub/openi-hack/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push[...newElements]` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport var SpliceBuffer = /*#__PURE__*/function () {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  function SpliceBuffer(initial) {\n    _classCallCheck(this, SpliceBuffer);\n    /** @type {Array<T>} */\n    this.left = initial ? _toConsumableArray(initial) : [];\n    /** @type {Array<T>} */\n    this.right = [];\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  _createClass(SpliceBuffer, [{\n    key: \"get\",\n    value: function get(index) {\n      if (index < 0 || index >= this.left.length + this.right.length) {\n        throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n      }\n      if (index < this.left.length) return this.left[index];\n      return this.right[this.right.length - index + this.left.length - 1];\n    }\n\n    /**\n     * The length of the splice buffer, one greater than the largest index in the\n     * array.\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.left.length + this.right.length;\n    }\n\n    /**\n     * Remove and return `list[0]`;\n     * moves the cursor to `0`.\n     *\n     * @returns {T | undefined}\n     *   Item, optional.\n     */\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      this.setCursor(0);\n      return this.right.pop();\n    }\n\n    /**\n     * Slice the buffer to get an array;\n     * does not move the cursor.\n     *\n     * @param {number} start\n     *   Start.\n     * @param {number | null | undefined} [end]\n     *   End (optional).\n     * @returns {Array<T>}\n     *   Array of items.\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(start, end) {\n      /** @type {number} */\n      var stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n      if (stop < this.left.length) {\n        return this.left.slice(start, stop);\n      }\n      if (start > this.left.length) {\n        return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n      }\n      return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n    }\n\n    /**\n     * Mimics the behavior of Array.prototype.splice() except for the change of\n     * interface necessary to avoid segfaults when patching in very large arrays.\n     *\n     * This operation moves cursor is moved to `start` and results in the cursor\n     * placed after any inserted items.\n     *\n     * @param {number} start\n     *   Start;\n     *   zero-based index at which to start changing the array;\n     *   negative numbers count backwards from the end of the array and values\n     *   that are out-of bounds are clamped to the appropriate end of the array.\n     * @param {number | null | undefined} [deleteCount=0]\n     *   Delete count (default: `0`);\n     *   maximum number of elements to delete, starting from start.\n     * @param {Array<T> | null | undefined} [items=[]]\n     *   Items to include in place of the deleted items (default: `[]`).\n     * @return {Array<T>}\n     *   Any removed items.\n     */\n  }, {\n    key: \"splice\",\n    value: function splice(start, deleteCount, items) {\n      /** @type {number} */\n      var count = deleteCount || 0;\n      this.setCursor(Math.trunc(start));\n      var removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n      if (items) chunkedPush(this.left, items);\n      return removed.reverse();\n    }\n\n    /**\n     * Remove and return the highest-numbered item in the array, so\n     * `list[list.length - 1]`;\n     * Moves the cursor to `length`.\n     *\n     * @returns {T | undefined}\n     *   Item, optional.\n     */\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      return this.left.pop();\n    }\n\n    /**\n     * Inserts a single item to the high-numbered side of the array;\n     * moves the cursor to `length`.\n     *\n     * @param {T} item\n     *   Item.\n     * @returns {undefined}\n     *   Nothing.\n     */\n  }, {\n    key: \"push\",\n    value: function push(item) {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      this.left.push(item);\n    }\n\n    /**\n     * Inserts many items to the high-numbered side of the array.\n     * Moves the cursor to `length`.\n     *\n     * @param {Array<T>} items\n     *   Items.\n     * @returns {undefined}\n     *   Nothing.\n     */\n  }, {\n    key: \"pushMany\",\n    value: function pushMany(items) {\n      this.setCursor(Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, items);\n    }\n\n    /**\n     * Inserts a single item to the low-numbered side of the array;\n     * Moves the cursor to `0`.\n     *\n     * @param {T} item\n     *   Item.\n     * @returns {undefined}\n     *   Nothing.\n     */\n  }, {\n    key: \"unshift\",\n    value: function unshift(item) {\n      this.setCursor(0);\n      this.right.push(item);\n    }\n\n    /**\n     * Inserts many items to the low-numbered side of the array;\n     * moves the cursor to `0`.\n     *\n     * @param {Array<T>} items\n     *   Items.\n     * @returns {undefined}\n     *   Nothing.\n     */\n  }, {\n    key: \"unshiftMany\",\n    value: function unshiftMany(items) {\n      this.setCursor(0);\n      chunkedPush(this.right, items.reverse());\n    }\n\n    /**\n     * Move the cursor to a specific position in the array. Requires\n     * time proportional to the distance moved.\n     *\n     * If `n < 0`, the cursor will end up at the beginning.\n     * If `n > length`, the cursor will end up at the end.\n     *\n     * @param {number} n\n     *   Position.\n     * @return {undefined}\n     *   Nothing.\n     */\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(n) {\n      if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n      if (n < this.left.length) {\n        // Move cursor to the this.left\n        var removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n        chunkedPush(this.right, removed.reverse());\n      } else {\n        // Move cursor to the this.right\n        var _removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n        chunkedPush(this.left, _removed.reverse());\n      }\n    }\n  }]);\n  return SpliceBuffer;\n}();\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  var chunkStart = 0;\n  if (right.length < 10000) {\n    list.push.apply(list, _toConsumableArray(right));\n  } else {\n    while (chunkStart < right.length) {\n      list.push.apply(list, _toConsumableArray(right.slice(chunkStart, chunkStart + 10000)));\n      chunkStart += 10000;\n    }\n  }\n}","map":{"version":3,"names":["SpliceBuffer","initial","_classCallCheck","left","_toConsumableArray","right","_createClass","key","value","get","index","length","RangeError","shift","setCursor","pop","slice","start","end","stop","undefined","Number","POSITIVE_INFINITY","reverse","concat","splice","deleteCount","items","count","Math","trunc","removed","chunkedPush","push","item","pushMany","unshift","unshiftMany","n","list","chunkStart","apply"],"sources":["C:/Users/320209843/Documents/GitHub/openi-hack/node_modules/micromark-util-subtokenize/lib/splice-buffer.js"],"sourcesContent":["/**\n * Some of the internal operations of micromark do lots of editing\n * operations on very large arrays. This runs into problems with two\n * properties of most circa-2020 JavaScript interpreters:\n *\n *  - Array-length modifications at the high end of an array (push/pop) are\n *    expected to be common and are implemented in (amortized) time\n *    proportional to the number of elements added or removed, whereas\n *    other operations (shift/unshift and splice) are much less efficient.\n *  - Function arguments are passed on the stack, so adding tens of thousands\n *    of elements to an array with `arr.push[...newElements]` will frequently\n *    cause stack overflows. (see <https://stackoverflow.com/questions/22123769/rangeerror-maximum-call-stack-size-exceeded-why>)\n *\n * SpliceBuffers are an implementation of gap buffers, which are a\n * generalization of the \"queue made of two stacks\" idea. The splice buffer\n * maintains a cursor, and moving the cursor has cost proportional to the\n * distance the cursor moves, but inserting, deleting, or splicing in\n * new information at the cursor is as efficient as the push/pop operation.\n * This allows for an efficient sequence of splices (or pushes, pops, shifts,\n * or unshifts) as long such edits happen at the same part of the array or\n * generally sweep through the array from the beginning to the end.\n *\n * The interface for splice buffers also supports large numbers of inputs by\n * passing a single array argument rather passing multiple arguments on the\n * function call stack.\n *\n * @template T\n *   Item type.\n */\nexport class SpliceBuffer {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    /** @type {Array<T>} */\n    this.left = initial ? [...initial] : [];\n    /** @type {Array<T>} */\n    this.right = [];\n  }\n\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError('Cannot access index `' + index + '` in a splice buffer of size `' + (this.left.length + this.right.length) + '`');\n    }\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length;\n  }\n\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    /** @type {number} */\n    const stop = end === null || end === undefined ? Number.POSITIVE_INFINITY : end;\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n    if (start > this.left.length) {\n      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();\n    }\n    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());\n  }\n\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    /** @type {number} */\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;\n    if (n < this.left.length) {\n      // Move cursor to the this.left\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      // Move cursor to the this.right\n      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n}\n\n/**\n * Avoid stack overflow by pushing items onto the stack in segments\n *\n * @template T\n *   Item type.\n * @param {Array<T>} list\n *   List to inject into.\n * @param {ReadonlyArray<T>} right\n *   Items to inject.\n * @return {undefined}\n *   Nothing.\n */\nfunction chunkedPush(list, right) {\n  /** @type {number} */\n  let chunkStart = 0;\n  if (right.length < 10000) {\n    list.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list.push(...right.slice(chunkStart, chunkStart + 10000));\n      chunkStart += 10000;\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}